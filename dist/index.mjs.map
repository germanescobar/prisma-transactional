{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\n\nexport type Context = {\n  tx: Partial<PrismaClient>\n}\n\nexport type PrismaProxyOptions = {\n  enableSavepoints: boolean\n}\n\n/**\n * Returns an proxy of PrismaClient that can be used to run transactions across functions.\n * \n * @param client the Prisma Client instance that will be proxied\n * @param asyncLocalStorage the asyncLocalStorage instance that will be used to store the transaction\n * @param options\n *          enableSavePoints: if true (default), it will use SAVEPOINTS to support nested transactions.\n * @returns \n */\nexport default function createPrismaProxy<T extends Context>(client: PrismaClient, asyncLocalStorage: AsyncLocalStorage<T>, options: PrismaProxyOptions = { enableSavepoints: true }) {\n  const createNestedTransaction = createNestedTransactionHandler(client, options.enableSavepoints);\n\n  const proxy = new Proxy(client, {\n    /**\n     * Intercepts access to all properties of the PrismaClient instance. If there's a transaction \n     * in the asyncLocalStorage, it will use it, otherwise it will use the original PrismaClient instance.\n     * \n     * If the property accessed is $transaction, it will create the transaction and add it to the asyncLocalStorage.\n     */\n    get(target: PrismaClient, prop) {\n      const tx = asyncLocalStorage.getStore()?.tx;\n      if (prop === '$transaction') {\n        if (!tx) {\n          return createTransactionHandler(asyncLocalStorage, target, prop)\n        } else if (options.enableSavepoints) {\n          return createNestedTransaction; \n        }\n      }\n      return Reflect.get(tx ?? target, prop);\n    },\n  });\n\n  return proxy;\n}\n\n/**\n * Returns the proxy of $transaction, which will create the transaction and store it in the asyncLocalStorage.\n * @param asyncLocalStorage \n * @param target the original PrismaClient instance\n * @param prop this is always $transaction at this point\n * @returns a function that can be used in the same way as prisma.$transaction.\n */\nfunction createTransactionHandler<T extends Context>(asyncLocalStorage: AsyncLocalStorage<T>, target: PrismaClient, prop: string) {\n  // get the original $transaction function from the PrismaClient instance\n  const $transaction = Reflect.get<PrismaClient, string>(target, prop);\n\n  // return a modified version that stores the transaction in the asyncLocalStorage\n  return async function(arg: (tx: PrismaClient) => Promise<any> | PromiseLike<unknown>[]) {\n    console.log(typeof arg);\n    if (Array.isArray(arg)) {\n      // just delegate to the original $transaction\n      return $transaction.call(target, arg);\n    } else {\n      return await $transaction.call(target, async (tx: PrismaClient) => {\n        return await asyncLocalStorage.run({ tx } as T, () => {\n          return arg(tx);\n        });\n      });\n    }\n  }\n}\n\n/**\n * Used to support nested transactions. Adapted from the jest-prisma project.\n */\nfunction createNestedTransactionHandler(parentTxClient: PrismaClient, enableSavepoints: boolean) {\n  let seq = 1;\n  const createNestedTransaction = async (arg: PromiseLike<unknown>[] | ((client: PrismaClient) => Promise<unknown>)) => {\n    const savePointId = `test_${seq++}`;\n    if (enableSavepoints) {\n      await parentTxClient.$executeRawUnsafe(`SAVEPOINT ${savePointId};`);\n    }\n    if (Array.isArray(arg)) {\n      try {\n        const results = [] as unknown[];\n        for (const prismaPromise of arg) {\n          const result = await prismaPromise;\n          results.push(result);\n        }\n        if (enableSavepoints) {\n          await parentTxClient.$executeRawUnsafe(`RELEASE SAVEPOINT ${savePointId};`);\n        }\n        return results;\n      } catch (err) {\n        if (enableSavepoints) {\n          await parentTxClient.$executeRawUnsafe(`ROLLBACK TO SAVEPOINT ${savePointId};`);\n        }\n        throw err;\n      }\n    } else {\n      try {\n        const result = await arg(parentTxClient);\n        if (enableSavepoints) {\n          await parentTxClient.$executeRawUnsafe(`RELEASE SAVEPOINT ${savePointId};`);\n        }\n        return result;\n      } catch (err) {\n        if (enableSavepoints) {\n          await parentTxClient.$executeRawUnsafe(`ROLLBACK TO SAVEPOINT ${savePointId};`);\n        }\n        throw err;\n      }\n    }\n  };\n  return createNestedTransaction;\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAoBe,SAAR,kBAAsD,QAAsB,mBAAyC,UAA8B,EAAE,kBAAkB,KAAK,GAAG;AACpL,QAAM,0BAA0B,+BAA+B,QAAQ,QAAQ,gBAAgB;AAE/F,QAAM,QAAQ,IAAI,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAO9B,IAAI,QAAsB,MAAM;AA9BpC;AA+BM,YAAM,MAAK,uBAAkB,SAAS,MAA3B,mBAA8B;AACzC,UAAI,SAAS,gBAAgB;AAC3B,YAAI,CAAC,IAAI;AACP,iBAAO,yBAAyB,mBAAmB,QAAQ,IAAI;AAAA,QACjE,WAAW,QAAQ,kBAAkB;AACnC,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,QAAQ,IAAI,kBAAM,QAAQ,IAAI;AAAA,IACvC;AAAA,EACF,CAAC;AAED,SAAO;AACT;AASA,SAAS,yBAA4C,mBAAyC,QAAsB,MAAc;AAEhI,QAAM,eAAe,QAAQ,IAA0B,QAAQ,IAAI;AAGnE,SAAO,SAAe,KAAkE;AAAA;AACtF,cAAQ,IAAI,OAAO,GAAG;AACtB,UAAI,MAAM,QAAQ,GAAG,GAAG;AAEtB,eAAO,aAAa,KAAK,QAAQ,GAAG;AAAA,MACtC,OAAO;AACL,eAAO,MAAM,aAAa,KAAK,QAAQ,CAAO,OAAqB;AACjE,iBAAO,MAAM,kBAAkB,IAAI,EAAE,GAAG,GAAQ,MAAM;AACpD,mBAAO,IAAI,EAAE;AAAA,UACf,CAAC;AAAA,QACH,EAAC;AAAA,MACH;AAAA,IACF;AAAA;AACF;AAKA,SAAS,+BAA+B,gBAA8B,kBAA2B;AAC/F,MAAI,MAAM;AACV,QAAM,0BAA0B,CAAO,QAA+E;AACpH,UAAM,cAAc,QAAQ,KAAK;AACjC,QAAI,kBAAkB;AACpB,YAAM,eAAe,kBAAkB,aAAa,WAAW,GAAG;AAAA,IACpE;AACA,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,UAAI;AACF,cAAM,UAAU,CAAC;AACjB,mBAAW,iBAAiB,KAAK;AAC/B,gBAAM,SAAS,MAAM;AACrB,kBAAQ,KAAK,MAAM;AAAA,QACrB;AACA,YAAI,kBAAkB;AACpB,gBAAM,eAAe,kBAAkB,qBAAqB,WAAW,GAAG;AAAA,QAC5E;AACA,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,YAAI,kBAAkB;AACpB,gBAAM,eAAe,kBAAkB,yBAAyB,WAAW,GAAG;AAAA,QAChF;AACA,cAAM;AAAA,MACR;AAAA,IACF,OAAO;AACL,UAAI;AACF,cAAM,SAAS,MAAM,IAAI,cAAc;AACvC,YAAI,kBAAkB;AACpB,gBAAM,eAAe,kBAAkB,qBAAqB,WAAW,GAAG;AAAA,QAC5E;AACA,eAAO;AAAA,MACT,SAAS,KAAK;AACZ,YAAI,kBAAkB;AACpB,gBAAM,eAAe,kBAAkB,yBAAyB,WAAW,GAAG;AAAA,QAChF;AACA,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;","names":[]}